![[Pasted image 20251220174814.png]]

## AWS serverless platform
Includes fully managed services that are tightly integrated with AWS Lambda and well-suited for serverless applications
- Developer tools, including AWS Serverless Application Model (AWS SAM)
- Helps simplify deployment of Lambda functions and serverless apps
- AWS Lambda is the compute service for serverless
![[Pasted image 20251220175739.png]]

# AWS Lambda
- Is a compute service
- Can **run code** without provisioning or maintaining servers
- **Initiates functions** in response to events
- **Scales** automatically
- Provides built-in code **monitoring & logging** via Amazon CloudWatch

## AWS Lambda features
- #### Bring own code
	- Write code using languages already know
	- Port code I/O of AWS
- #### Integrates with & extends other AWS services
	- Calling AWS SDK, invoking APIs
	- Whether on AWS, in a datacenter or on the internet
- #### Flexible resource and concurrency
	- Scales in response to events
	- Only configure memory settings
	- AWS handles details such as CPU, network, I/O
- #### Flexible permissions model
	- Uses AWS Identity & Access Management (IAM) to securely grant access to resources
	- Provide fine-grained control to invoke functions
- #### Availability and fault tolerance are built in
	- Lambda is a fully managed service
	- HIgh availability & fault tolerance are built into the service
- #### Pay for value
	- Lambda functions only run when initiated
	- Pay only for the compute time that being consumed
	- When code is invoked, billed in 1ms increments
## Event-driven architectures
- Uses events to initiate actions and communication between decoupled services
- An event is a change in state, a user request, or an update
- When an event occurs, the information is published for other services to consume it

- In event-driven architectures, events are the primary mechanism for sharing info across services
- These are observable, such as a new message in a log, rather than directed, such as a command to do something
## Producers, routers, consumers
AWS Lambda is an example of an event-driven architecture
- Most AWS services generate events and act as an event source for Lambda
- Lambda runs custom code (functions) in response to events
- Lambda functions are designed to process these events and, once invoked, initiate other actions or events
![[Pasted image 20251220190951.png]]
## What is a Lambda function
- The code on AWS Lambda is called a _Lambda function_
- Lambda functions are _stateless_, with no affinity to the underlying infrastructure
- Lambda can launch as many copies of the function as needed to scale to the rate of incoming events
![[Pasted image 20251220192035.png]]

# How AWS Lambda Works
## Invocation models for running Lambda functions
- Event sources can invoke a Lambda function in three general patterns --> Called invocation models
- Invocation model depends on the event source being used
- #### Synchronous invocation
	- Lambda runs the function and waits for a response
	- When function completes, Lambda returns the response from the function's code with additional data
	- Synchronous events expect an immediate response from the function invocation
	- There are no built-in retries --> Manage retry strategy within the app code
- #### Asynchronous invocation
	- Events are queued and the requestor doesn't wait for the function to complete
	- This model is appropriate when the client doesn't need an immediate response
	- Can make use of destinations to send records of async invocations to other services
- #### Polling invocation
	- Designed to integrate with AWS streaming and queuing based services with no code or server management
	- Lambda will poll these services, retrieve any matching events, and invoke functions
	- The retry behavior varies depending on the event source and its configuration

## Invocation model error behavior
![[Pasted image 20251220194538.png]]

## Lambda execution environment
## Execution environment lifecycle
Lambda uses config info to set up the execution environment
- #### Init phase
	- Happens during the first invocation or before function invocations
		- 1. Extension init - starts all extensions
		- 2. Runtime init - bootstraps the runtime
		- 3. Function init - runs the function's static code
	- Lambda creates or unfreezes an execution environment with the configured resources
		- Downloads the code for the function, initializes extensions and the runtime, and then runs the function’s initialization code
- #### Invoke phase
	- Lambda invokes the function handler
	- After the function runs to completion, Lambda prepares to handle another function invocation
- #### Shutdown phase
	- It initiates if the Lambda function does not receive any invocations for a period of time
	- Lambda shuts down the runtime, alerts the extensions to stop cleanly, and then removes the environment
- ![[Pasted image 20251220204932.png]]

## Performance optimization
While Lambda manages scaling automatically, I can optimize the individual Lambda functions used in the app to reduce latency and increase throughput

### Cold and warm starts
- A **cold start** occurs when a new execution environment is required to run a Lambda function
	- When the service receives a request to run a function, it first prepares an execution environment
- A **warm start** retains the environment instead of destroying it immediately
	- This allows the function to run again within the same execution environment
	- Saves time by not needing to initialize the environment
- ![[Pasted image 20251220205546.png]]

### Write functions to take advantage of warm starts
1. Store and reference dependencies locally
2. Limit re-initialization of variables
3. Add code to check for and reuse existing connections
4. Use tmp space as transient cache
5. Check that background processes have completed

# AWS Lambda Function Permissions
- Permission to invoke the function
- Permission of the Lambda function itself to act upon other services
- Permissions to invoke the function are controlled using an IAM resource-based policy
	- Defines the permissions that control what the function is allowed to do when interacting with other AWS services
	- ![[Pasted image 20251221090203.png]]

## Execution role
- Gives the function permissions to interact with other services
- This role is provided when a function is created, and Lambda assumes the role when the function is invoked

## Resource-based policy
![[Pasted image 20251221091216.png]]
-  Tells the Lambda service which principals have permission to invoke the Lambda function
	- A user, role, another AWS service, or another AWS acc
- Makes it easy to grant access to the Lambda function across separate AWS accounts

## Policy comparison
- #### Resource-based policy
	- Associated with a "push" event source like Amazon API Gateway
	- Created when a trigger added to a Lambda function
	- Allows the event source to take the _lambda:InvokeFunction_ action
- #### IAM execution role
	- Selected or created when you create a Lambda function
	- IAM policy includes actions you can take with the resource
	- Trust policy that allows Lambda to _AssumeRole_
	- Creator must have permission for _iam:PassRole_

# Authoring AWS Lambda Functions
- Can use the programming language and IDE that you are most familiar with and use the code that you've already written
- The code might need some minor adjustments to make it serverless
![[Pasted image 20251221093729.png]]

## Handler method
- Is the method in the function code that processes events
- When the function is invoked, Lambda runs the handler method
- When the handler exits or returns a response, it becomes available to handle another event
- The handler method takes two objects – the event object and the context object
- #### Event Object
	- Is required
	- When the Lambda function is invoked in one of the supported languages, one of the parameters provided to the handler function is an **event object**
	- The event object differs in structure and contents, depending on which event source created it
	- The contents of the event parameter include all of the data and metadata the Lambda function needs to drive its logic
- #### Context Object
	- Allows the function code to interact with the Lambda execution environment
	- The contents and structure of the context object vary, based on the language runtime the Lambda function is using
		- **AWS RequestID**
		- **Runtime**
		- **Logging**

## Best practices for writing code
- **Include logging statements**
- **Use return coding**
- **Provide environment variables**
- **Add secret and reference data**
- **Avoid recursive code**
- **Gather metrics with Amazon CloudWatch**
- **Reuse execution context**

### Lambda console editor
![[Pasted image 20251221102255.png]]
### Deployment packages
- Lambda supports two types of deployment packages: container images and .zip file archives
- Create and upload a .zip file to S3 or use a container image and push to Amazon Elastic Container Registry (Amazon ECR)
### Automate using tools
- Automate the deployment process of your applications by using AWS SAM and other AWS services
	- Ex: AWS CodeBuild, CodeDeploy, and CodePipeline

## What is AWS SAM
- Open-source framework for building serverless applications
- Provides shorthand syntax to express functions, APIs, databases, and event source mappings
- Can define the application you want and model it using YAML
![[Pasted image 20251221103715.png]]

## AWS SAM CLI
- Launches a Docker container that you can interact with to test and debug Lambda functions
- Local testing will only cover a subset of what must be tested before code should go into your production application
![[Pasted image 20251221104358.png]]

### AWS SAM CLI commands
- **init** -> Initializes a serverless app
- **local** -> Runs the app locally
- **validate** -> Validates an AWS SAM template
- **deploy** -> Deploys an AWS SAM app
- **build** -> Builds a serverless app and prepares it for subsequent steps in the workflow
## Serverless CI/CD pipeline
![[Pasted image 20251221104728.png]]
Can incorporate additional tools to create an automated CI/CD pipeline for serverless apps that integrate with AWS SAM
- **CodeBuild** -> Automate the process of packaging code and running tests before the code is deployed
- **CodeDeploy** -> Use version management options to ensure safe deployments to prod
![[Pasted image 20251221105321.png]]

# Configuring Lambda Functions
- Must specify three primary configuration settings: memory, timeout, and concurrency
- Important in defining how each function performs
- Comes down to testing the function in real-world scenarios and against peak volume
- Must adjust settings to optimize costs and ensure the desired customer experience with your application

### Memory
- Can allocate up to 10 GB of memory to a Lambda function
- Lambda allocates CPU and other resources linearly in proportion to the amount of memory configured
- Increase in memory size triggers an equivalent increase in CPU available to the function
### Timeout
- Dictates how long a function can run before Lambda terminates the Lambda function
- A single invocation of a Lambda function cannot run longer than 900 seconds
- Set the timeout for a Lambda function to the maximum only after you test your function
### Lambda billing costs
- Pay only for what you use
- Charged based on the number of requests for your functions and the duration, the time it takes for the code to run

## Concurrency and scaling
- Concurrency is the number of invocations your function runs at any given moment
- When your function is invoked, Lambda launches an instance of the function to process the event
- Having more than one invocation running at the same time is the function's concurrency
## Concurrency types
- #### Unreserved concurrency
	- The amount of concurrency that is not allocated to any specific set of functions
	- This allows functions that do not have any provisioned concurrency to still be able to run
- #### Reserved concurrency
	- Guarantees the maximum number of concurrent instances for the function
	- When a function has reserved concurrency, no other function can use that concurrency
	- No charge is incurred for configuring reserved concurrency for a function
- #### Provisioned concurrency
	- Initializes a requested number of runtime environments so that they are prepared to respond immediately to function's invocations
	- This option is used when you need high performance and low latency

